package controller

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"time"
)

type Asset struct {
	BrowserDownloadURL string `json:"browser_download_url"`
}
type Release struct {
	Assets      []Asset   `json:"assets"`
	Name        string    `json:"name"`
	TagName     string    `json:"tag_name"`
	PublishedAt time.Time `json:"published_at"`
}

func fetchReleases(url string, date time.Time) ([]Release, error) {
	token := os.Getenv("github_token")
	var allReleases []Release
	page := 1

	fetchAndFilterReleases := func(page int) ([]Release, error) {
		req, err := http.NewRequest("GET", fmt.Sprintf("%s?page=%d&per_page=100", url, page), nil)
		if err != nil {
			return nil, err
		}
		req.Header.Set("Authorization", fmt.Sprintf("token %s", token))
		req.Header.Set("Accept", "application/vnd.github.v3+json")

		client := &http.Client{}
		resp, err := client.Do(req)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			bodyBytes, _ := ioutil.ReadAll(resp.Body)
			bodyString := string(bodyBytes)
			return nil, fmt.Errorf("received non-200 status code %d, response: %s", resp.StatusCode, bodyString)
		}

		// Read the response body
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}

		// Unmarshal the JSON response
		var releases []Release
		if err := json.Unmarshal(body, &releases); err != nil {
			return nil, err
		}

		// Filter releases by the start date
		var filteredReleases []Release
		for _, release := range releases {
			if release.PublishedAt.After(date) {
				filteredReleases = append(filteredReleases, release)
			}
		}
		return filteredReleases, nil
	}
	for {
		releases, err := fetchAndFilterReleases(page)
		if err != nil {
			log.Fatalf("Error fetching releases: %v", err)
		}
		if len(releases) == 0 {
			break
		}
		allReleases = append(allReleases, releases...)
		page++
	}
	return allReleases, nil
}
