/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"

	cvemonitorv1 "github.com/csye7125-su24-team17/cve-operator.git/api/v1"
)

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	HttpClient *http.Client // Capitalize the H to export it (make it accessible from main.go where it is being initialized)
	Scheme     *runtime.Scheme
}

// RBAC permissions to access GitHubReleasesMonitor and GitHubRelease resources. These permissions ensure the controller can manage these resources properly.

// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors/finalizers,verbs=update

// Reconcile manages the state of the GitHubReleasesMonitor resources within the cluster, aligning it with the desired state defined by CRDs.
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	_ = log.FromContext(ctx)

	// Fetch the GitHubReleasesMonitor instance (CR) from the cluster. CR provides the inputs (like URL and MonitorFrom) to the controller.
	var monitor cvemonitorv1.GitHubReleasesMonitor
	if err := r.Get(ctx, req.NamespacedName, &monitor); err != nil {
		log.FromContext(ctx).Error(err, "unable to fetch GitHubReleasesMonitor")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	creationTimestamp := monitor.ObjectMeta.CreationTimestamp
	startDateTime := creationTimestamp.Time
	if monitor.Spec.MonitorFrom == "now" {
		startDateTime = startDateTime.UTC()
	} else if monitor.Spec.MonitorFrom == "date" {
		startDateTime = time.Date(startDateTime.UTC().Year(), startDateTime.UTC().Month(), startDateTime.UTC().Day(), 0, 0, 0, 0, time.UTC)
	} else {
		layout := "2006-01-02T15:04:05Z"
		givenTime , err := time.Parse(layout, monitor.Spec.MonitorFrom)
		if err != nil {
			fmt.Println("Error parsing time:", err)
			return ctrl.Result{}, err
		}
		startDateTime = givenTime
	}

	log.FromContext(ctx).Info("Fetching GitHub releases....")
	releases, err := fetchReleases(monitor.Spec.URL, startDateTime)
	if err != nil {
		log.FromContext(ctx).Error(err, "Failed to fetch releases from GitHub")
		return ctrl.Result{}, err
	}

	log.FromContext(ctx).Info("Iterating through each fetched GitHub release....")
	for _, release := range releases {
		if len(release.Assets) == 2 {
			continue
		}
		namespace := os.Getenv("namespace")
		name := fmt.Sprintf("github-release-cve-%s", sanitizeTagName(release.TagName))
		githubRelease := &cvemonitorv1.GitHubRelease{
			ObjectMeta: metav1.ObjectMeta{
				Name:      name,
				Namespace: namespace,
			},
			Spec: cvemonitorv1.GitHubReleaseSpec{
				DeltaZipUrl: release.Assets[1].BrowserDownloadURL,
			},
			Status: cvemonitorv1.GitHubReleaseStatus{
				JobStatus: "pending",
			},
		}
		if err := controllerutil.SetControllerReference(&monitor, githubRelease, r.Scheme); err != nil {
			log.FromContext(ctx).Error(err, "Error setting owner as Controller OwnerReference on controlled")
		}
		existingGitHubRelease := &cvemonitorv1.GitHubRelease{}
		err := r.Get(ctx, client.ObjectKey{Name: githubRelease.Name, Namespace: githubRelease.Namespace}, existingGitHubRelease)
		if err != nil {
			if errors.IsNotFound(err) {
				if err := r.Create(ctx, githubRelease); err != nil {
					log.FromContext(ctx).Error(err, "Error creating new GitHubRelease")
				} else {
					log.FromContext(ctx).Info(fmt.Sprintf("Created a new GitHubRelease: %s\n", githubRelease.Name))
				}
			} else {
				// Error occurred while fetching the resource
				return ctrl.Result{}, err
			}
		} else {
			log.FromContext(ctx).Info(fmt.Sprintf("Skipping creation of existting GitHubRelease: %s\n", githubRelease.Name))
		}
	}
	// Update the status of the GitHubReleasesMonitor CR to reflect the latest state.
	err = r.updateStatus(ctx, &monitor, releases)
	if err != nil {
		log.FromContext(ctx).Error(err, "Failed to update GitHubReleasesMonitor status")
	} else {
		log.FromContext(ctx).Info("Updated status of GitHubReleaseMonitor CR")
	}

	requeue, ok := os.LookupEnv("reconciler_requeue")
	if !ok {
		requeue = "1"
	}
	requeueAfter, _ := strconv.Atoi(requeue)
	return ctrl.Result{RequeueAfter: time.Duration(requeueAfter) * time.Minute}, nil
}

// sanitizeTagName takes a GitHub release tag name and converts it into K8s compatible resource name (that complies with DNS label standards)
func sanitizeTagName(tagName string) string {
	sanitized := strings.ToLower(tagName)
	sanitized = strings.ReplaceAll(sanitized, "_", "-")
	sanitized = strings.ReplaceAll(sanitized, " ", "-")
	return sanitized
}

// updateStatus updates the status of the GitHubReleasesMonitor with the observed releases.
func (r *GitHubReleasesMonitorReconciler) updateStatus(ctx context.Context, monitor *cvemonitorv1.GitHubReleasesMonitor, releases []Release) error {
	var observedReleases []string
	for _, release := range releases {
		observedReleases = append(observedReleases, release.TagName)
	}
	monitor.Status.ObservedReleases = observedReleases
	monitor.Status.LastCheckedTime = metav1.Now()

	// return r.Status().Update(ctx, monitor)
	if err := r.Status().Patch(ctx, monitor, client.MergeFrom(monitor.DeepCopy())); err != nil {
		return err
	} else {
		return nil
	}
}

func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&cvemonitorv1.GitHubReleasesMonitor{}).
		Owns(&cvemonitorv1.GitHubRelease{}).
		Complete(r)
}
