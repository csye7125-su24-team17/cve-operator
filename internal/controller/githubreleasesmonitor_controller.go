/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"net/http"
	"strings"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"

	cvemonitorv1 "github.com/csye7125-su24-team17/cve-operator.git/api/v1"
)

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	HttpClient *http.Client // Capitalize the H to export it (make it accessible from main.go where it is being initialized)
	Scheme     *runtime.Scheme
}

// RBAC permissions to access GitHubReleasesMonitor and GitHubRelease resources. These permissions ensure the controller can manage these resources properly.

// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors/finalizers,verbs=update

// Reconcile manages the state of the GitHubReleasesMonitor resources within the cluster, aligning it with the desired state defined by CRDs.
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	_ = log.FromContext(ctx)

	// Fetch the GitHubReleasesMonitor instance (CR) from the cluster. CR provides the inputs (like URL and MonitorFrom) to the controller.
	var monitor cvemonitorv1.GitHubReleasesMonitor
	if err := r.Get(ctx, req.NamespacedName, &monitor); err != nil {
		log.FromContext(ctx).Error(err, "unable to fetch GitHubReleasesMonitor")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	var startDate time.Time
	if monitor.Spec.MonitorFrom == "now" {
		year, month, day, hour, min, sec, nsec := time.Now().UTC().Year(), time.Now().UTC().Month(), time.Now().UTC().Day(), time.Now().UTC().Hour(), time.Now().UTC().Minute(), time.Now().UTC().Second(), time.Now().UTC().Nanosecond()
		startDate = time.Date(year, month, day, hour, min, sec, nsec, time.UTC)
	} else {
		year, month, day := time.Now().UTC().Year(), time.Now().UTC().Month(), time.Now().UTC().Day()
		startDate = time.Date(year, month, day, 0, 0, 0, 0, time.UTC)
	}

	log.FromContext(ctx).Info("Fetching GitHub releases....")
	releases, err := fetchReleases(monitor.Spec.URL, startDate)
	if err != nil {
		log.FromContext(ctx).Error(err, "Failed to fetch releases from GitHub")
		return ctrl.Result{}, err
	}

	log.FromContext(ctx).Info("Iterating through each fetched GitHub release....")
	for _, release := range releases {
		if len(release.Assets) == 2 {
			continue
		}
		name := fmt.Sprintf("github-release-cve-%s", sanitizeTagName(release.TagName))
		githubRelease := &cvemonitorv1.GitHubRelease{
			ObjectMeta: metav1.ObjectMeta{
				Name:      name,
				Namespace: "default",
			},
			Spec: cvemonitorv1.GitHubReleaseSpec{
				DeltaZipUrl: release.Assets[1].BrowserDownloadURL,
			},
			// Status: cvemonitorv1.GitHubReleaseStatus{

			// },
		}
		if err := controllerutil.SetControllerReference(&monitor, githubRelease, r.Scheme); err != nil {
			return reconcile.Result{}, err
		}
		existingGitHubRelease := &cvemonitorv1.GitHubRelease{}
		err := r.Get(ctx, client.ObjectKey{Name: githubRelease.Name, Namespace: githubRelease.Namespace}, existingGitHubRelease)
		if err != nil && errors.IsNotFound(err) {
			if err := r.Create(ctx, githubRelease); err != nil {
				return reconcile.Result{}, err
			}
			log.FromContext(ctx).Info(fmt.Sprintf("Created a new GitHubRelease: %s\n", githubRelease.Name))
		} else if err != nil {
			log.FromContext(ctx).Info(fmt.Sprintf("Skipping creation of existting GitHubRelease: %s\n", githubRelease.Name))
			return reconcile.Result{}, err
		}
	}

	// Update the status of the GitHubReleasesMonitor CR to reflect the latest state.
	err = r.updateStatus(ctx, &monitor, releases)
	if err != nil {
		log.FromContext(ctx).Error(err, "Failed to update GitHubReleasesMonitor status")
		return ctrl.Result{}, err
	}

	// Schedule the next reconciliation to run after 1 hour, effectively polling the GitHub repository periodically.
	return ctrl.Result{RequeueAfter: 1 * time.Hour}, nil

} // end of Reconcile fucntion

// sanitizeTagName takes a GitHub release tag name and converts it into K8s compatible resource name (that complies with DNS label standards)
func sanitizeTagName(tagName string) string {
	sanitized := strings.ToLower(tagName)
	sanitized = strings.ReplaceAll(sanitized, "_", "-")
	sanitized = strings.ReplaceAll(sanitized, " ", "-")
	return sanitized
}

// updateStatus updates the status of the GitHubReleasesMonitor with the observed releases.
func (r *GitHubReleasesMonitorReconciler) updateStatus(ctx context.Context, monitor *cvemonitorv1.GitHubReleasesMonitor, releases []Release) error {
	var observedReleases []string
	for _, release := range releases {
		observedReleases = append(observedReleases, release.TagName)
	}
	monitor.Status.ObservedReleases = observedReleases
	monitor.Status.LastCheckedTime = metav1.Now()

	return r.Status().Update(ctx, monitor)
}

func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&cvemonitorv1.GitHubReleasesMonitor{}).
		Owns(&cvemonitorv1.GitHubRelease{}).
		Complete(r)
}
