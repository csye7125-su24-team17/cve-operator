/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"net/http"
	"strings"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	cvemonitorv1 "github.com/csye7125-su24-team17/cve-operator.git/api/v1"
)

// GitHubReleaseAsset represents the downloadable assets within a GitHub release.
type GitHubReleaseAsset struct {
	Name               string `json:"name"`
	BrowserDownloadURL string `json:"browser_download_url"`
}

// GitHubRelease captures the essential details of a release fetched from GitHub.
type GitHubRelease struct {
	TagName     string               `json:"tag_name"`
	PublishedAt string               `json:"published_at"`
	Assets      []GitHubReleaseAsset `json:"assets"`
}

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	HttpClient *http.Client // Capitalize the H to export it (make it accessible from main.go where it is being initialized)
	Scheme     *runtime.Scheme
}

// RBAC permissions to access GitHubReleasesMonitor and GitHubRelease resources. These permissions ensure the controller can manage these resources properly.

// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cvemonitor.csye7125-su24-team17.com,resources=githubreleasesmonitors/finalizers,verbs=update

// Reconcile manages the state of the GitHubReleasesMonitor resources within the cluster, aligning it with the desired state defined by CRDs.
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	_ = log.FromContext(ctx)

	// Fetch the GitHubReleasesMonitor instance (CR) from the cluster. CR provides the inputs (like URL and MonitorFrom) to the controller.
	var monitor cvemonitorv1.GitHubReleasesMonitor
	if err := r.Get(ctx, req.NamespacedName, &monitor); err != nil {
		log.FromContext(ctx).Error(err, "unable to fetch GitHubReleasesMonitor")
		// If the GitHubReleasesMonitor resource no longer exists, there's nothing to reconcile.
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// Parse the MonitorFrom time to determine which releases are relevant.
	monitorFrom, err := parseMonitorFrom(monitor.Spec.MonitorFrom, monitor.ObjectMeta.CreationTimestamp.Time)
	if err != nil {
		log.FromContext(ctx).Error(err, "Invalid monitorFrom value")
		return ctrl.Result{}, err
	}

	// Retrieve the latest releases from the specified GitHub repository.
	releases, err := r.fetchGitHubReleases(ctx, monitor.Spec.URL)
	if err != nil {
		log.FromContext(ctx).Error(err, "Failed to fetch releases from GitHub")
		return ctrl.Result{}, err
	}

	log.FromContext(ctx).Info("Iterating through each fetched GitHub release....")

	// Iterate through each release fetched from GitHub to process only the relevant ones.
	for _, release := range releases {
		releaseTime, err := time.Parse(time.RFC3339, release.PublishedAt)
		if err != nil {
			log.FromContext(ctx).Error(err, "Failed to parse release publication time", "ReleaseTag", release.TagName)
			continue // If time parsing fails, skip this release
		}

		// Check if the release's publication time is after the monitorFrom time to ensure it's relevant.
		if releaseTime.After(monitorFrom) {
			sanitizedTagName := sanitizeTagName(release.TagName) // Sanitize the release's tag name to ensure it conforms to Kubernetes naming conventions
			logger := log.FromContext(ctx).WithValues("ReleaseTag", release.TagName, "ReleaseTime", release.PublishedAt)
			logger.Info("Processing release")

			// Iterate through each asset associated with the current release.
			for _, asset := range release.Assets {
				// Check if the asset is a delta ZIP file, indicating it contains CVE updates.
				if isDeltaZip(asset.Name) {
					exists, err := r.githubReleaseCRExists(ctx, sanitizedTagName, monitor.Namespace)
					if err != nil {
						logger.Error(err, "Error checking existence of GitHubRelease", "AssetName", asset.Name)
						continue // Skip this asset on error
					}
					if exists {
						logger.Info("GitHubRelease already exists, skipping creation", "AssetName", asset.Name)
						continue // Skip this asset as it already exists
					}

					// Try to create a GitHubRelease custom resource for this asset.
					if err := r.createGitHubReleaseCR(ctx, sanitizedTagName, asset.BrowserDownloadURL, monitor.Namespace); err != nil {
						logger.Error(err, "Failed to create GitHubRelease CR", "AssetName", asset.Name)
					} else {
						logger.Info("Successfully created GitHubRelease CR", "AssetName", asset.Name)
					}
				} else {
					logger.Info("Asset is not a delta ZIP file, skipping", "AssetName", asset.Name)
				}
			}
		} else {
			log.FromContext(ctx).Info("Skipping release as it is older than monitorFrom time", "ReleaseTag", release.TagName, "ReleaseTime", release.PublishedAt)
		}
	}

	// Update the status of the GitHubReleasesMonitor CR to reflect the latest state.
	err = r.updateStatus(ctx, &monitor, releases)
	if err != nil {
		log.FromContext(ctx).Error(err, "Failed to update GitHubReleasesMonitor status")
		return ctrl.Result{}, err
	}

	// Schedule the next reconciliation to run after 1 hour, effectively polling the GitHub repository periodically.
	return ctrl.Result{RequeueAfter: 1 * time.Hour}, nil

} // end of Reconcile fucntion

// fetchGitHubReleases contacts GitHub's API to fetch the latest releases
func (r *GitHubReleasesMonitorReconciler) fetchGitHubReleases(ctx context.Context, url string) ([]GitHubRelease, error) {
	logger := log.FromContext(ctx)
	logger.Info("Starting to fetch releases from GitHub", "URL", url)

	resp, err := r.HttpClient.Get(url)
	if err != nil {
		logger.Error(err, "Error fetching releases from GitHub", "URL", url)
		return nil, err
	}
	defer resp.Body.Close()
	logger.Info("Successfully fetched releases from GitHub", "URL", url)

	var releases []GitHubRelease
	if err := json.NewDecoder(resp.Body).Decode(&releases); err != nil {
		logger.Error(err, "Error decoding releases from GitHub", "URL", url)
		return nil, err
	}
	logger.Info("Successfully decoded releases from GitHub", "URL", url, "Count", len(releases))

	return releases, nil
}

// sanitizeTagName takes a GitHub release tag name and converts it into K8s compatible resource name (that complies with DNS label standards)
func sanitizeTagName(tagName string) string {
	sanitized := strings.ToLower(tagName)
	sanitized = strings.ReplaceAll(sanitized, "_", "-")
	sanitized = strings.ReplaceAll(sanitized, " ", "-")
	return sanitized
}

// isDeltaZip checks if the asset name matches the pattern of delta ZIP files.
func isDeltaZip(filename string) bool {
	return strings.Contains(filename, "delta_CVEs_at")
}

// githubReleaseCRExists checks the existence of a GitHubRelease CR in the namespace.
func (r *GitHubReleasesMonitorReconciler) githubReleaseCRExists(ctx context.Context, sanitizedTagName string, namespace string) (bool, error) {
	var release cvemonitorv1.GitHubRelease
	resourceName := "github-release-cr-" + sanitizedTagName
	err := r.Get(ctx, client.ObjectKey{Name: resourceName, Namespace: namespace}, &release)
	return err == nil, client.IgnoreNotFound(err)
}

// createGitHubReleaseCR creates a new GitHubRelease CR in the specified namespace.
func (r *GitHubReleasesMonitorReconciler) createGitHubReleaseCR(ctx context.Context, sanitizedTagName, url, namespace string) error {
	resourceName := "github-release-cr-" + sanitizedTagName
	release := cvemonitorv1.GitHubRelease{
		ObjectMeta: metav1.ObjectMeta{
			Name:      resourceName,
			Namespace: namespace,
		},
		Spec: cvemonitorv1.GitHubReleaseSpec{
			DeltaZipUrl: url,
		},
	}
	return r.Create(ctx, &release)
}

// updateStatus updates the status of the GitHubReleasesMonitor with the observed releases.
func (r *GitHubReleasesMonitorReconciler) updateStatus(ctx context.Context, monitor *cvemonitorv1.GitHubReleasesMonitor, releases []GitHubRelease) error {
	var observedReleases []string
	for _, release := range releases {
		observedReleases = append(observedReleases, release.TagName)
	}
	monitor.Status.ObservedReleases = observedReleases
	monitor.Status.LastCheckedTime = metav1.Now()

	return r.Status().Update(ctx, monitor)
}

// parseMonitorFrom interprets the monitorFrom string to determine the starting point for monitoring.
func parseMonitorFrom(monitorFromStr string, creationTime time.Time) (time.Time, error) {
	if monitorFromStr == "now" {
		return creationTime, nil
	}
	return time.Parse(time.RFC3339, monitorFromStr)
}

// SetupWithManager sets up the controller with the Manager.
func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&cvemonitorv1.GitHubReleasesMonitor{}).
		Complete(r)
}
